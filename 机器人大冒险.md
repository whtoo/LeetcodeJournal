# é¢˜ç›®æè¿°
```
åŠ›æ‰£å›¢é˜Ÿä¹°äº†ä¸€ä¸ªå¯ç¼–ç¨‹æœºå™¨äººï¼Œæœºå™¨äººåˆå§‹ä½ç½®åœ¨åŸç‚¹(0, 0)ã€‚å°ä¼™ä¼´äº‹å…ˆç»™æœºå™¨äººè¾“å…¥ä¸€ä¸²æŒ‡ä»¤commandï¼Œæœºå™¨äººå°±ä¼šæ— é™å¾ªç¯è¿™æ¡æŒ‡ä»¤çš„æ­¥éª¤è¿›è¡Œç§»åŠ¨ã€‚æŒ‡ä»¤æœ‰ä¸¤ç§ï¼š

U: å‘yè½´æ­£æ–¹å‘ç§»åŠ¨ä¸€æ ¼
R: å‘xè½´æ­£æ–¹å‘ç§»åŠ¨ä¸€æ ¼ã€‚
ä¸å¹¸çš„æ˜¯ï¼Œåœ¨ xy å¹³é¢ä¸Šè¿˜æœ‰ä¸€äº›éšœç¢ç‰©ï¼Œä»–ä»¬çš„åæ ‡ç”¨obstaclesè¡¨ç¤ºã€‚æœºå™¨äººä¸€æ—¦ç¢°åˆ°éšœç¢ç‰©å°±ä¼šè¢«æŸæ¯ã€‚

ç»™å®šç»ˆç‚¹åæ ‡(x, y)ï¼Œè¿”å›æœºå™¨äººèƒ½å¦å®Œå¥½åœ°åˆ°è¾¾ç»ˆç‚¹ã€‚å¦‚æœèƒ½ï¼Œè¿”å›trueï¼›å¦åˆ™è¿”å›falseã€‚

Â 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šcommand = "URR", obstacles = [], x = 3, y = 2
è¾“å‡ºï¼štrue
è§£é‡Šï¼šU(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)ã€‚
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šcommand = "URR", obstacles = [[2, 2]], x = 3, y = 2
è¾“å‡ºï¼šfalse
è§£é‡Šï¼šæœºå™¨äººåœ¨åˆ°è¾¾ç»ˆç‚¹å‰ä¼šç¢°åˆ°(2, 2)çš„éšœç¢ç‰©ã€‚
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šcommand = "URR", obstacles = [[4, 2]], x = 3, y = 2
è¾“å‡ºï¼štrue
è§£é‡Šï¼šåˆ°è¾¾ç»ˆç‚¹åï¼Œå†ç¢°åˆ°éšœç¢ç‰©ä¹Ÿä¸å½±å“è¿”å›ç»“æœã€‚
Â 

é™åˆ¶ï¼š

2 <= commandçš„é•¿åº¦ <= 1000
commandç”±Uï¼ŒRæ„æˆï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ªUï¼Œè‡³å°‘æœ‰ä¸€ä¸ªR
0 <= x <= 1e9, 0 <= y <= 1e9
0 <= obstaclesçš„é•¿åº¦ <= 1000
obstacles[i]ä¸ä¸ºåŸç‚¹æˆ–è€…ç»ˆç‚¹

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/programmable-robot
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

è§£é¢˜åˆ†æ:
   1. å‡ºå‘ç‚¹
    è€ƒè™‘é¢˜ç›®ç»™å‡ºçš„æ¡ä»¶,æˆ‘ä»¬éœ€è¦è€ƒè™‘æœ€å°‘éœ€è¦çš„è®¡ç®—æ¬¡æ•°,æ‰èƒ½ä¿è¯ä¸æ¼ä¸é‡çš„æ£€æŸ¥å®Œæ‰€æœ‰ç‚¹.
    æ ¹æ®é¢˜ç›®æ¡ä»¶,éå†commandsè‡³å°‘æ˜¯O(m),è€Œobstaclesè‡³å°‘æ˜¯O(n).
    ç”±ä¸Šå¯çŸ¥,æˆ‘ä»¬çŒœæµ‹æœ€å°‘éœ€è¦çš„æ­¥éª¤ä¸ºO(m+n).
    2. æ¡ä»¶æŒ–æ˜
       1. æ—¢ç„¶,æˆ‘ä»¬è¦è¾¾åˆ°O(m+n),è‡ªç„¶éœ€è¦åˆ†åˆ«éå†commandså’Œobstacles.
          1. éå†commandsåªéœ€è¦ä¸€é,è¿™æ˜¯ä¸ºäº†æ‰¾åˆ°ç¬¬ä¸€ä¸ªå‘¨æœŸçš„path
          2. éå†obstacleåˆ™éœ€è¦è€ƒè™‘,æ€ä¹ˆè£å‰ªæœç´¢ç©ºé—´.
       2. æ³¨æ„åˆ°æ¡ä»¶è¯´æ˜,å¦‚æœå…ˆåˆ°è¾¾ä¸”åœ¨æ­¤ä¹‹å‰æ²¡æœ‰ç¢°æ’,åˆ™å¯è§†ä¸ºæˆåŠŸ.äºæ˜¯,æˆ‘ä»¬è€ƒè™‘èƒ½å¦é€šè¿‡destæ¥ç¼©å°æœç´¢åŸŸ.æ³¨æ„ç¬¦åˆæ¡ä»¶çš„ç‚¹çš„æœ‰å¦‚ä¸‹ç‰¹æ€§:(obstacle.x <= dest.x && obstack.y <= dest.y)ä¸”pathæ˜¯æœ‰åºçš„,é‚£ä¹ˆå¯ä»¥éå†æŸ¥æ‰¾obstacle.å¦‚æœ,æ­¤æ—¶æ‰¾åˆ°ç¢°æ’,åˆ™è¿”å›false,å¦åˆ™,è¿”å›ä¸Šä¸€æ­¥çš„æ˜¯å¦å¯è¾¾æ ‡è®°.
        
    3. æˆ‘çš„ä»£ç å®ç°
   ```
/**
 * @param {string} command
 * @param {number[][]} obstacles
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
var robot = function (command, obstacles, x, y) {
    // é¢„åˆ¤ä¸ºå‘¨æœŸé—®é¢˜,åˆ™å¿…é¡»è€ƒè™‘å…ˆæ‰¾ä¸€ä¸ªå‘¨æœŸå†…çš„è§„å¾‹
    // ç”±æ¡ä»¶çŸ¥,å¿…é¡»å…ˆå°†commandsè§£æå‡ºæ¥
    let path = []
    let origin = [0, 0]
    path.push[origin]
    let c = ''

    for (i = 0; i < command.length; i++) {
        c = command[i]
        if (c == "U") {
            origin[1] += 1
        } else {
            origin[0] += 1
        }
        path.push([origin[0], origin[1]])
    }
    let vec = path.pop()
    path.push(vec)
    let flag = checkPos([x, y], vec, path)

    if (!flag) {
        return false
    }

    let crashed = obstacles.filter((val) => val[0] <= x && val[1] <= y).find(obstacle => checkPos(obstacle, vec, path))

    if (flag && !crashed) {
        return true
    }
    return false
}
/**
 * @param {number[]} obstacle
 * @param {number[]} vec 
 * @param {number[][]} path
 */
function checkPos(obstacle, vec, path) {
    let scaleX = Math.ceil(obstacle[0] / vec[0]) - 1
    let scaleY = Math.ceil(obstacle[1] / vec[1]) - 1
    let scale = Math.max(scaleX, scaleY)
    obstacle[0] -= (scale * vec[0])
    obstacle[1] -= (scale * vec[1])
    if(path.find(pos => pos[0] == obstacle[0] && pos[1] == obstacle[1])){
        return true
    }
    
    return false
}

   ```
   Hashè§£æ³•(ç”±äºcommandséƒ½æ¯”è¾ƒå°,ä¸”setåœ¨jsè¿™è¾¹é€Ÿåº¦ä¼˜åŠ¿å¹¶ä¸æ˜æ˜¾,äºæ˜¯è¿™ä¸ªè§£æ³•å¹³å‡è¿è¡Œé€Ÿè¯»åè€Œä½äºä¸Šé¢çš„ğŸ˜‚)
   ```
   /**
 * @param {string} command
 * @param {number[][]} obstacles
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
var robot = function (command, obstacles, x, y) {
    // é¢„åˆ¤ä¸ºå‘¨æœŸé—®é¢˜,åˆ™å¿…é¡»è€ƒè™‘å…ˆæ‰¾ä¸€ä¸ªå‘¨æœŸå†…çš„è§„å¾‹
    // ç”±æ¡ä»¶çŸ¥,å¿…é¡»å…ˆå°†commandsè§£æå‡ºæ¥
    let path = new Set()
    let origin = [0, 0]
    path.add(0)
    let c = ''

    for (i = 0; i < command.length; i++) {
        c = command[i]
        if (c == "U") {
            origin[1] += 1
        } else {
            origin[0] += 1
        }
        path.add(origin[0] << 24 | origin[1])
    }

    let vec = origin
    let flag = checkPos([x, y], vec, path)

    if (!flag) {
        return false
    }

    let crashed = obstacles.filter((val) => val[0] <= x && val[1] <= y).find(obstacle => checkPos(obstacle, vec, path))
if(crashed){
    console.log(crashed)
}
    if (flag && !crashed) {
        return true
    }
    return false
}
/**
 * @param {number[]} pos
 * @param {number[]} vec 
 * @param {set} path
 */
function checkPos(pos, vec, path) {
    let scaleX = Math.ceil(pos[0] / vec[0]) - 1
    let scaleY = Math.ceil(pos[1] / vec[1]) - 1
    let scale = Math.max(scaleX, scaleY)
    let flag = false
    pos[0] -= (scale * vec[0])
    pos[1] -= (scale * vec[1])

    if (path.has(pos[0] << 24 | pos[1])) {
        return true
    }

    return false
}
   ```